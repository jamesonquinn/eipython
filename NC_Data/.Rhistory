install.packages("rstan")
install.packages(c("data.table", "MCMCpack", "rstan"))
library(rstan)
library(MCMCpack)
library(data.table)
# Using the model in rxc_beta_binomial.stan
###################################################
# Parameters to set:
stan_testing = 1
ER_testing = 0
R = 3 # number of races
C = 3 # number of candidates
M = 100  # number of precincts
Nmin = 100 # min number of people per precinct
Nmax = 500 # max number of people per precinct
x_prior = c(1,1,1) # Dirichlet prior for values of X
lambda = 0.01 # rate of exponential from which we draw the alphas
####################################################
# Generate data not sampled from the model (N and x)
# ----------------------------------------------------------
# N = number of people per precinct
N <- sample(Nmin:Nmax, M, replace=T)
# x (percent of each race) for each precinct
x <- rdirichlet(M, x_prior)
# Generate parameters and data from model:
# ----------------------------------------
alphas = array(dim=c(R,C))
betas = array(dim = c(M,R,C))
p = array(dim = c(M,R,C))
v = array(dim = c(M,C))
# Parameters for each race:
for (r in 1:R) {
# Dirichlet parameters for each race and candidate
alphas[r,1:C] <- rexp(n=C,rate=lambda)
# Precinct probabilities for each race and candidate
for (j in 1:M) {
betas[j,r,1:C] <- rdirichlet(1,alphas[r,1:C])
# Actual precinct percentages for each race and candidate
p[j,r,1:C] <- rmultinom(1, round(x[j,r]*N[j]), betas[j,r,1:C])
p[j,r,1:C] <- p[j,r,1:C]/round(x[j,r]*N[j])
}
}
# Voting data for each precinct
for (j in 1:M) {
for (c in 1:C) {
v[j,c] = sum(x[j,1:R] * p[j,1:R,c])
}
}
###############################################
# Inference using Stan (model in rxc_beta_binomial.stan)
data <- list(R=R, C=C, M=M, N=N, v=v, x=x)
ei_model <- stan_model(file = "rxc_beta_binomial.stan")
show(ei_model)
library(rstan)
# Using the model in dp_normal.stan:
# Let's generate some data from the model
J = 40 # number of schools
mu = 0  # mean of hyperdistribution
tau = 1  # sd of hyperdistribution
mu_site <- rnorm(J, mu, tau)
se_site = rnorm(J, .5, 0.1)  #standard error
y <- rnorm(J,mu_site,se_site)
data <-
list(J=c(J),y_site_obs=c(y),se_site =c(se_site))
fit <- stan(file = 'dp_normal.stan', data = data,
iter = 1000, chains = 5)
print(fit, pars=c("mu_true", "sigma_true"))
params = extract(fit)
mu_inf = c()
for(i in 1:J) {
mu_inf = c(mu_inf,mean(params$y_site_true[,i]))
}
# plot
plot(mu_site,mu_site, type="l")
points(mu_site,y, col="blue")
points(mu_site,mu_inf, col="red")
library(rstan)
library(MCMCpack)
library(data.table)
# Using the model in rxc_beta_binomial.stan
###################################################
# Parameters to set:
stan_testing = 1
ER_testing = 0
R = 3 # number of races
C = 3 # number of candidates
M = 100  # number of precincts
Nmin = 100 # min number of people per precinct
Nmax = 500 # max number of people per precinct
x_prior = c(1,1,1) # Dirichlet prior for values of X
lambda = 0.01 # rate of exponential from which we draw the alphas
####################################################
# Generate data not sampled from the model (N and x)
# ----------------------------------------------------------
# N = number of people per precinct
N <- sample(Nmin:Nmax, M, replace=T)
# x (percent of each race) for each precinct
x <- rdirichlet(M, x_prior)
# Generate parameters and data from model:
# ----------------------------------------
alphas = array(dim=c(R,C))
betas = array(dim = c(M,R,C))
p = array(dim = c(M,R,C))
v = array(dim = c(M,C))
# Parameters for each race:
for (r in 1:R) {
# Dirichlet parameters for each race and candidate
alphas[r,1:C] <- rexp(n=C,rate=lambda)
# Precinct probabilities for each race and candidate
for (j in 1:M) {
betas[j,r,1:C] <- rdirichlet(1,alphas[r,1:C])
# Actual precinct percentages for each race and candidate
p[j,r,1:C] <- rmultinom(1, round(x[j,r]*N[j]), betas[j,r,1:C])
p[j,r,1:C] <- p[j,r,1:C]/round(x[j,r]*N[j])
}
}
# Voting data for each precinct
for (j in 1:M) {
for (c in 1:C) {
v[j,c] = sum(x[j,1:R] * p[j,1:R,c])
}
}
###############################################
# Inference using Stan (model in rxc_beta_binomial.stan)
data <- list(R=R, C=C, M=M, N=N, v=v, x=x)
ei_model <- stan_model(file = "./rxc_beta_binomial.stan")
show(ei_model)
R.Version()
install.packages('devtools') #assuming it is not already installed
library(devtools)
install_github('andreacirilloac/updateR')
updateR(admin_password = 'Admin user password')
install.packages("brms")
system("clang++ -v")
library("brms")
data("kidney", package = "brms")
head(kidney)
get_prior(time | cens(censored)  Ìƒ age * sex + disease + (1 + age | patient), data = kidney, family = lognormal())
get_prior(time | cens(censored)  ~ age * sex + disease + (1 + age | patient), data = kidney, family = lognormal())
fit1 <- brm(formula = time | cens(censored) ~ age * sex + disease + (1 + age|patient),
data = kidney, family = lognormal(),
prior = c(set_prior("normal(0,5)", class = "b"),
set_prior("cauchy(0,2)", class = "sd"),
set_prior("lkj(2)", class = "cor")), warmup = 1000,
iter = 2000, chains = 4, control = list(adapt_delta = 0.95)))
fit1 <- brm(formula = time | cens(censored) ~ age * sex + disease + (1 + age|patient),
data = kidney, family = lognormal(),
prior = c(set_prior("normal(0,5)", class = "b"),
set_prior("cauchy(0,2)", class = "sd"),
set_prior("lkj(2)", class = "cor")), warmup = 1000,
iter = 2000, chains = 4, control = list(adapt_delta = 0.95))
fit1 <- brm(formula = time | cens(censored) ~ age * sex + disease + (1 + age|patient),
data = kidney, family = lognormal(),
prior = c(set_prior("normal(0,5)", class = "b"),
set_prior("cauchy(0,2)", class = "sd"),
set_prior("lkj(2)", class = "cor")), warmup = 1000,
iter = 2000, chains = 4, control = list(adapt_delta = 0.95)))
fit1 <- brm(formula = time | cens(censored) ~ age * sex + disease + (1 + age|patient),
data = kidney, family = lognormal(),
prior = c(set_prior("normal(0,5)", class = "b"),
set_prior("cauchy(0,2)", class = "sd"),
set_prior("lkj(2)", class = "cor")), warmup = 1000,
iter = 2000, chains = 4, control = list(adapt_delta = 0.95))
version
update()
load("~/Dropbox (Mathcamp)/EI/NC_Data/ProcessedData/data_for_analysis.Rdata")
source('~/Dropbox (Mathcamp)/EI/NC_Data/ProcessedData/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
cast(sample,.=year,sum)
dcast(sample,.=year,sum)
dcast(sample,.~year,sum)
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
View(sample)
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
dim(sample)
dim(sample)[1]
repeat(1,3)
rep(1,3)
install.packages("sampling")
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
sampling_probabilities
v = UPminimalsupport(sampling_probabilities)
v
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
v
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
View(data)
source('~/Dropbox (Mathcamp)/EI/NC_Data/make_sample_for_simulation.R')
